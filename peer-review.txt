Design Critique:
The code we were provided for this assignment was comprehensive and was more than capable of carrying out all responsibilities. The interfaces properly captured all necessary functionalities of Reversi whether it was for the view, the strategies, or the features. The fact that the right methods were made available through the interfaces helped to facilitate its integration with our code (specifically when creating adapters to converge the codes, we were able to easily map functions to their equivalents). Another thing that came to mind was the high level of abstraction that was prominent in the code. A key example is with the strategies - the strategies classes purely determined possible moves, and then when passed into other helper classes were able to output the selected move. Within the strategies as well the methods were broken down into appropriate helpers. The tie-breaking was also abstracted into its helper class which not only minimized code reuse but also could facilitate reimplementation if new strategies are created in the future. On the topic of the strategies, I appreciated the providers’ use of Optional, as it would give a better return output (cleaner and easier to check for) in case the Strategy was unable to find a move and decided to pass instead.

Implementation Critique:
The various components of the code were able to integrate well, and there was not much coupling between pieces. The code made strong use of the observer pattern to transmit key “status updates” between the controller, the view, and the model. The self-contained nature of the view was also something that we took note of and discussed with the providers, as to how it was capable of handling operations independently. One thing that caught our attention however was, the absence of a typical “hexagon” class made. This slightly obfuscates the user’s understanding of how and where the hexagons are created for the UI. While the overall implementation was effective, this area could benefit from a more modular approach, as breaking it down could help both functionality and code readability.

Documentation critique:
For the documentation, I will comment that initially, it was a little difficult to understand how the parts of the providers’ strategy/ai came together (ie. calling the strategy class in a wrapper class, then passing that wrapper into a tiebreaker object to output a single coordinate). While we understand the merits of this design in terms of abstraction, I just think this could have been better documented to show users the flow of how the strategies would fit together. Similarly, it could have helped if how the view came together and its self-contained nature were also better documented as well. Aside from this, however, all key methods and pieces were effectively documented which helped us understand the responsibilities of the different methods and parts.

Limitations + Solutions:
Lack of hexagon class: Implementing a dedicated class for hexagon-related functionalities + how a hexagon would be drawn and constructed could have both helped in the GUI development and also could have benefits in how information about each hexagon was accessed as well as improved code readability.

Enhanced Documentation on Strategy Integration + View and how large components come together: Providing more detailed documentation on how different strategy components fit together would help in better understanding and utilizing certain aspects of the code more effectively. Also could have better documentation on which strategies are infallible vs fallible so the user's know they cant use a fallible strategy standalone. The strategy wrapper should be better documented as it could be a common misconception that the strategies return the right moves and it just needs to be sorted through by the TieBreaker, but the wrapper is also needed.

Consolidate Duplicate Implementations: We noticed there were some overlapping implementations, such as the clone board method, but this is just a small thing that could help make cleaner code.

Overall, I felt very positive about working with this code and felt that it followed and made use of many OOD/OOP principles to reduce coupling and maintain functionality. We did not need to ask for any changes to their code but were lucky that the providers were very accommodating in helping explain areas of their code that needed some clarification.